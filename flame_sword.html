<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Inferno Blade: AR Hand Tracking</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
        }

        /* The Camera Feed (Mirrored) */
        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.4; /* Dimmed so the sword pops more */
        }

        /* The 3D Layer */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10;
            pointer-events: none;
        }

        /* HUD UI */
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            z-index: 20;
            color: #ff4500;
            text-shadow: 0 0 10px #ff0000;
        }

        h1 {
            margin: 0;
            font-size: 2rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            border-bottom: 2px solid #ff4500;
            display: inline-block;
            padding-bottom: 5px;
        }

        #status {
            margin-top: 10px;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .loader {
            border: 4px solid #333;
            border-top: 4px solid #ff4500;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #energy-bar {
            width: 200px;
            height: 6px;
            background: #333;
            margin-top: 10px;
            border-radius: 3px;
            overflow: hidden;
        }

        #energy-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff8800, #ff0000);
            transition: width 0.1s;
        }
    </style>
</head>
<body>

    <video id="webcam" autoplay playsinline></video>
    
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>Inferno Blade</h1>
        <div id="status-container">
            <div id="loader" class="loader"></div>
            <span id="status">INITIALIZING SYSTEM...</span>
        </div>
        <div id="energy-bar"><div id="energy-fill"></div></div>
        <div style="margin-top:8px; font-size: 0.8rem; opacity: 0.8;">
            GESTURE: SNAP (Thumb+Middle) to Ignite<br>
            ACTION: SWING FAST to Generate Fire
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        // --- CONFIGURATION ---
        const SETTINGS = {
            cameraWidth: 1280,
            cameraHeight: 720,
            bladeColorCore: 0xffffff,
            bladeColorOuter: 0xff4500, // Fiery Orange
            particleCount: 150,
            swordLength: 4.5,
            smoothSpeed: 0.15
        };

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer;
        let swordGroup, bladeMesh, guardMesh, hiltMesh, auraMesh;
        let handLandmarker;
        let video = document.getElementById('webcam');
        let canvasContainer = document.getElementById('canvas-container');
        let statusText = document.getElementById('status');
        let loader = document.getElementById('loader');
        let energyFill = document.getElementById('energy-fill');
        
        let isSwordActive = false;
        let lastVideoTime = -1;
        
        // Physics / Movement Tracking
        let targetPos = new THREE.Vector3(0, 0, 0);
        let targetRot = new THREE.Quaternion();
        let currentVel = 0;
        let lastPos = new THREE.Vector3();
        
        // Particle System
        const particles = [];

        // --- INITIALIZATION ---
        async function init() {
            createScene();
            createSword();
            createParticles(); // Initialize pool
            await initMediaPipe();
            startCamera();
            animate();
        }

        // --- THREE.JS SCENE SETUP ---
        function createScene() {
            scene = new THREE.Scene();
            // Standard perspective camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10; // Pull back to see the "mirror" plane

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            canvasContainer.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffaa00, 1, 20);
            pointLight.position.set(2, 2, 5);
            scene.add(pointLight);
        }

        // --- PROCEDURAL SWORD GENERATION ---
        function createSword() {
            swordGroup = new THREE.Group();

            // 1. The Hilt (Handle)
            const hiltGeo = new THREE.CylinderGeometry(0.15, 0.12, 1.2, 8);
            const hiltMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111, roughness: 0.8, metalness: 0.5 
            });
            hiltMesh = new THREE.Mesh(hiltGeo, hiltMat);
            hiltMesh.position.y = -0.6;
            swordGroup.add(hiltMesh);

            // 2. The Guard (Crossguard) - Built from boxes for a rugged look
            const guardGeo = new THREE.BoxGeometry(1.2, 0.2, 0.3);
            const guardMat = new THREE.MeshStandardMaterial({ 
                color: 0x333333, metalness: 1.0, roughness: 0.3 
            });
            guardMesh = new THREE.Mesh(guardGeo, guardMat);
            guardMesh.position.y = 0;
            
            // Add spikes to guard
            const spikeGeo = new THREE.ConeGeometry(0.1, 0.4, 4);
            const spike1 = new THREE.Mesh(spikeGeo, guardMat);
            spike1.position.set(0.6, 0.1, 0);
            spike1.rotation.z = -Math.PI / 2;
            guardMesh.add(spike1);
            
            const spike2 = spike1.clone();
            spike2.position.set(-0.6, 0.1, 0);
            spike2.rotation.z = Math.PI / 2;
            guardMesh.add(spike2);
            
            swordGroup.add(guardMesh);

            // 3. The Blade Core (White Hot)
            const bladeGeo = new THREE.CylinderGeometry(0.05, 0.15, SETTINGS.swordLength, 8);
            bladeGeo.translate(0, SETTINGS.swordLength / 2, 0); // Pivot at bottom
            const bladeMat = new THREE.MeshBasicMaterial({ 
                color: SETTINGS.bladeColorCore 
            });
            bladeMesh = new THREE.Mesh(bladeGeo, bladeMat);
            bladeMesh.scale.set(1, 0.001, 1); // Start retracted
            swordGroup.add(bladeMesh);

            // 4. The Blade Aura (Transparent Fire)
            const auraGeo = new THREE.CylinderGeometry(0.2, 0.4, SETTINGS.swordLength + 0.2, 16, 4, true);
            auraGeo.translate(0, (SETTINGS.swordLength + 0.2) / 2, 0);
            const auraMat = new THREE.MeshBasicMaterial({
                color: SETTINGS.bladeColorOuter,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            auraMesh = new THREE.Mesh(auraGeo, auraMat);
            auraMesh.scale.set(1, 0.001, 1);
            swordGroup.add(auraMesh);

            scene.add(swordGroup);
        }

        // --- PARTICLE SYSTEM (FIRE EFFECT) ---
        function createParticles() {
            const geometry = new THREE.PlaneGeometry(0.4, 0.4);
            const material = new THREE.MeshBasicMaterial({
                color: SETTINGS.bladeColorOuter,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            for (let i = 0; i < SETTINGS.particleCount; i++) {
                const p = new THREE.Mesh(geometry, material.clone());
                p.visible = false;
                scene.add(p);
                particles.push({
                    mesh: p,
                    life: 0,
                    velocity: new THREE.Vector3()
                });
            }
        }

        function spawnParticle(position, velocityStrength) {
            // Find a dead particle
            const p = particles.find(p => p.life <= 0);
            if (!p) return;

            // Reset state
            p.life = 1.0; // 100% life
            p.mesh.visible = true;
            p.mesh.position.copy(position);
            
            // Randomize position slightly for volume
            p.mesh.position.x += (Math.random() - 0.5) * 0.5;
            p.mesh.position.y += (Math.random() - 0.5) * 0.5;
            p.mesh.position.z += (Math.random() - 0.5) * 0.5;

            // Random rotation
            p.mesh.rotation.z = Math.random() * Math.PI;

            // Initial scale
            p.mesh.scale.setScalar(0.5 + Math.random() * 0.5);
            p.mesh.material.opacity = 0.8;
        }

        function updateParticles() {
            particles.forEach(p => {
                if (p.life > 0) {
                    p.life -= 0.02; // Decay rate
                    
                    // Rise up (heat rises)
                    p.mesh.position.y += 0.05; 
                    
                    // Shrink and fade
                    p.mesh.scale.setScalar(p.life);
                    p.mesh.material.opacity = p.life;
                    
                    // Color shift from Yellow -> Red -> Dark
                    if(p.life < 0.5) p.mesh.material.color.setHex(0xff0000);
                    else p.mesh.material.color.setHex(SETTINGS.bladeColorOuter);

                } else {
                    p.mesh.visible = false;
                }
            });
        }

        // --- MEDIAPIPE SETUP ---
        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            statusText.innerText = "CAMERA ACCESS REQUIRED";
            loader.style.display = "none";
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: SETTINGS.cameraWidth, height: SETTINGS.cameraHeight } });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    statusText.innerText = "SYSTEM ACTIVE";
                    statusText.style.color = "#00ff00";
                    predictLoop();
                });
            } catch (err) {
                statusText.innerText = "CAMERA DENIED";
                console.error(err);
            }
        }

        // --- TRACKING LOOP ---
        function predictLoop() {
            if (video.currentTime !== lastVideoTime && handLandmarker) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                
                if (results.landmarks && results.landmarks.length > 0) {
                    const landmarks = results.landmarks[0];
                    updateSwordPosition(landmarks);
                }
            }
            requestAnimationFrame(predictLoop);
        }

        function updateSwordPosition(landmarks) {
            // Key Landmarks
            const wrist = landmarks[0];
            const middleFingerMCP = landmarks[9]; // Knuckle
            const middleFingerTip = landmarks[12];
            const thumbTip = landmarks[4];

            // 1. Calculate Position (Mirror X)
            // Screen coords are 0-1. Three.js world is approx -8 to 8 depending on Z.
            // Z depth multiplier: We amplify the Z movement for drama.
            const x = (wrist.x - 0.5) * -16; // Flipped X
            const y = -(wrist.y - 0.5) * 12; // Inverted Y
            // MediaPipe Z is relative to wrist. We use it to push sword in/out of screen.
            const z = -wrist.z * 15; 
            
            targetPos.set(x, y, z);

            // 2. Calculate Orientation (Pointing Logic)
            // Vector from wrist to middle finger tip determines direction
            const dirX = (middleFingerTip.x - wrist.x) * -1; // Flip X direction
            const dirY = -(middleFingerTip.y - wrist.y);
            const dirZ = -(middleFingerTip.z - wrist.z); // Depth difference

            // Create a rotation matrix looking at the direction
            const dummyEye = new THREE.Vector3(x, y, z);
            const dummyTarget = new THREE.Vector3(x + dirX, y + dirY, z + dirZ * 2); // Multiply Z for sensitive pointing
            const dummyObj = new THREE.Object3D();
            dummyObj.position.copy(dummyEye);
            dummyObj.lookAt(dummyTarget);
            
            // Adjust so the blade (Y-axis) points along the vector
            dummyObj.rotateX(Math.PI / 2); 
            
            targetRot.copy(dummyObj.quaternion);

            // 3. Gesture Detection (Snap)
            const snapDist = Math.hypot(thumbTip.x - middleFingerTip.x, thumbTip.y - middleFingerTip.y);
            if (snapDist < 0.04) {
                if(!isSwordActive) triggerAction("IGNITE");
            }

            // 4. Calculate Velocity for Effects
            const distMoved = lastPos.distanceTo(targetPos);
            currentVel = distMoved; // Store for particle system
        }

        function triggerAction(action) {
            if (action === "IGNITE") {
                isSwordActive = true;
                statusText.innerText = "PLASMA IGNITED";
                statusText.style.color = "#ff4500";
            }
        }

        // --- ANIMATION LOOP (RENDER) ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Smooth Movement (Lerp)
            swordGroup.position.lerp(targetPos, SETTINGS.smoothSpeed);
            swordGroup.quaternion.slerp(targetRot, SETTINGS.smoothSpeed);

            // 2. Blade Animation
            const targetScale = isSwordActive ? 1 : 0.001;
            bladeMesh.scale.y += (targetScale - bladeMesh.scale.y) * 0.1;
            auraMesh.scale.y = bladeMesh.scale.y;

            // 3. Dynamic Visuals
            if (isSwordActive) {
                // Flicker Effect
                const flicker = 1 + Math.random() * 0.2;
                auraMesh.scale.x = flicker;
                auraMesh.scale.z = flicker;
                
                // Spawn Particles based on Velocity
                // If moving fast, spawn more. If still, spawn few (idle burn).
                const spawnRate = Math.floor(currentVel * 20) + 1; 
                
                // Calculate tip position for particle emission
                const tipPos = new THREE.Vector3(0, SETTINGS.swordLength * bladeMesh.scale.y, 0);
                tipPos.applyMatrix4(swordGroup.matrixWorld); // Transform local tip to world space
                
                // Interpolate along the blade for a full trail
                for(let i=0; i<spawnRate; i++) {
                    const r = Math.random();
                    const particlePos = new THREE.Vector3().lerpVectors(swordGroup.position, tipPos, r);
                    spawnParticle(particlePos, currentVel);
                }
            }

            // 4. Update Physics
            updateParticles();
            lastPos.copy(swordGroup.position);
            
            // Update UI Bar
            const energy = Math.min(currentVel * 100, 100);
            energyFill.style.width = energy + "%";

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        init();
    </script>
</body>
</html>